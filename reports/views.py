# apps/reports/views.py
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, JsonResponse
from django.contrib import messages
from django.utils import timezone
from django.db.models import Count, Sum, Avg, Q
from django.core.files.base import ContentFile
import json
from datetime import datetime, timedelta

from .models import Report
from startups.models import Startup
from projects.models import Project
from tasks.models import Task
from investments.models import Investment
from funding.models import FundingApplication

@login_required
def manager_reports(request):
    """Venture Manager Reports Dashboard"""
    if request.user.role.lower() != 'manager':
        messages.error(request, 'Access denied. Manager role required.')
        return redirect('dashboard_redirect')
    
    # Get all startups in the manager's portfolio
    startups = Startup.objects.all()  # Or filter by manager's portfolio
    
    # Get all projects
    projects = Project.objects.select_related('startup').prefetch_related('team_members')
    
    # Calculate portfolio statistics
    total_startups = startups.count()
    total_projects = projects.count()
    
    # Calculate financial metrics (you'll need to add these fields to your models)
    total_capital_deployed = sum(startup.total_funding or 0 for startup in startups)
    quarterly_revenue = sum(startup.quarterly_revenue or 0 for startup in startups)
    
    # Calculate project status metrics
    active_projects = projects.filter(status='in_progress').count()
    completed_projects = projects.filter(status='completed').count()
    delayed_projects = projects.filter(status='delayed').count()
    on_track_percentage = (active_projects / total_projects * 100) if total_projects > 0 else 0
    
    # Calculate stage distribution
    stage_distribution = startups.values('stage').annotate(
        count=Count('id'),
        percentage=Count('id') * 100 / total_startups
    )
    
    # Calculate industry breakdown
    industry_breakdown = startups.values('industry').annotate(
        count=Count('id'),
        percentage=Count('id') * 100 / total_startups
    )
    
    # Performance metrics for each startup
    performance_metrics = []
    for startup in startups:
        startup_projects = projects.filter(startup=startup)
        total_startup_projects = startup_projects.count()
        completed_startup_projects = startup_projects.filter(status='completed').count()
        
        # Calculate performance score (simplified - you can enhance this)
        if total_startup_projects > 0:
            completion_rate = (completed_startup_projects / total_startup_projects) * 100
        else:
            completion_rate = 0
            
        # Determine status based on completion rate
        if completion_rate >= 80:
            status = 'Exceeding'
            status_badge = 'success'
        elif completion_rate >= 60:
            status = 'On Track'
            status_badge = 'warning'
        else:
            status = 'At Risk'
            status_badge = 'danger'
            
        performance_metrics.append({
            'startup': startup,
            'stage': startup.stage or 'Seed',
            'revenue_growth': getattr(startup, 'revenue_growth', 15),  # Mock data - replace with actual
            'valuation_change': getattr(startup, 'valuation_change', 1.2),  # Mock data
            'burn_rate': getattr(startup, 'monthly_burn_rate', 50000),  # Mock data
            'team_growth': getattr(startup, 'team_growth', 5),  # Mock data
            'status': status,
            'status_badge': status_badge,
            'completion_rate': completion_rate
        })
    
    # Key Performance Indicators (mock data - replace with actual calculations)
    kpis = {
        'portfolio_irr': 28.5,
        'cash_on_cash': 2.8,
        'tvpi': 1.4,
        'dpi': 0.3
    }
    
    # Get reports generated by this user
    user_reports = Report.objects.filter(generated_by=request.user).order_by('-created_at')
    total_reports = user_reports.count()
    recent_reports = user_reports[:3]
    
    context = {
        'total_startups': total_startups,
        'total_capital_deployed': total_capital_deployed,
        'quarterly_revenue': quarterly_revenue,
        'average_multiple': 3.2,  # Mock data
        'on_track_percentage': on_track_percentage,
        'needs_attention': delayed_projects,
        'stage_distribution': stage_distribution,
        'industry_breakdown': industry_breakdown,
        'performance_metrics': performance_metrics,
        'kpis': kpis,
        'reports': user_reports,
        'total_reports': total_reports,
        'recent_reports': recent_reports,
    }
    
    return render(request, 'manager/reports.html', context)

@login_required
def investor_reports(request):
    """Investor Reports Dashboard (Read-only)"""
    if request.user.role.lower() != 'investor':
        messages.error(request, 'Access denied. Investor role required.')
        return redirect('dashboard_redirect')
    
    # Get reports generated by this user
    user_reports = Report.objects.filter(generated_by=request.user).order_by('-created_at')
    
    # Portfolio statistics for quick overview
    investments = request.user.investments.select_related('startup').all()
    total_invested = investments.aggregate(Sum('amount'))['amount__sum'] or 0
    portfolio_value = sum(inv.current_value for inv in investments)
    
    context = {
        'reports': user_reports,
        'total_invested': total_invested,
        'portfolio_value': portfolio_value,
        'investment_count': investments.count(),
    }
    
    return render(request, 'investor/reports.html', context)

@login_required
def generate_manager_report(request):
    """Generate reports for Venture Manager"""
    if request.user.role.lower() != 'manager':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        report_type = request.POST.get('report_type')
        date_range = request.POST.get('date_range', 'all_time')
        
        # Generate report data based on type
        report_data = generate_report_data(report_type, date_range, request.user)
        
        # Create report record
        report_name = f"{report_type.replace('_', ' ').title()} Report - {timezone.now().strftime('%Y-%m-%d')}"
        
        report = Report.objects.create(
            name=report_name,
            report_type=report_type,
            generated_by=request.user,
            content=report_data
        )
        
        # Optionally generate PDF file (you'd implement this)
        # pdf_file = generate_pdf_report(report_data)
        # report.file.save(f'{report_name}.pdf', ContentFile(pdf_file))
        
        messages.success(request, f'{report_name} generated successfully!')
        return redirect('reports:manager_reports')
    
    # GET request - show report generation form
    return render(request, 'manager/generate_report.html')

@login_required
def generate_investor_report(request):
    """Generate reports for Investor"""
    if request.user.role.lower() != 'investor':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        report_type = request.POST.get('report_type')
        date_range = request.POST.get('date_range', 'all_time')
        
        # Generate investor-specific report data
        report_data = generate_investor_report_data(report_type, date_range, request.user)
        
        # Create report record
        report_name = f"{report_type.replace('_', ' ').title()} Report - {timezone.now().strftime('%Y-%m-%d')}"
        
        report = Report.objects.create(
            name=report_name,
            report_type=report_type,
            generated_by=request.user,
            content=report_data
        )
        
        messages.success(request, f'{report_name} generated successfully!')
        return redirect('reports:investor_reports')
    
    # GET request - show report generation form
    return render(request, 'investor/generate_report.html')

@login_required
def report_detail(request, pk):
    """View detailed report"""
    report = get_object_or_404(Report, pk=pk)
    
    # Check permissions - users can only view their own reports
    if report.generated_by != request.user:
        messages.error(request, 'You do not have permission to view this report.')
        return redirect('ashboard_redirect')
    
    template_map = {
        'manager': 'manager/report_detail.html',
        'investor': 'investor/report_detail.html',
    }
    template = template_map.get(request.user.role.lower(), 'report_detail.html')
    
    return render(request, template, {'report': report})

@login_required
def download_report(request, pk):
    """Download report file"""
    report = get_object_or_404(Report, pk=pk)
    
    # Check permissions
    if report.generated_by != request.user:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if report.file:
        response = HttpResponse(report.file.read(), content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{report.name}.pdf"'
        return response
    else:
        messages.error(request, 'No file available for download.')
        return redirect('reports:report_detail', pk=pk)

@login_required
def delete_report(request, pk):
    """Delete a report"""
    report = get_object_or_404(Report, pk=pk)
    
    # Check permissions
    if report.generated_by != request.user:
        messages.error(request, 'You do not have permission to delete this report.')
        return redirect('reports:manager_reports')
    
    if request.method == 'POST':
        report_name = report.name
        report.delete()
        messages.success(request, f'Report "{report_name}" deleted successfully!')
        
        if request.user.role.lower() == 'manager':
            return redirect('reports:manager_reports')
        else:
            return redirect('reports:investor_reports')
    
    return render(request, 'confirm_delete.html', {'report': report})






@login_required
def manager_reports(request):
    """Venture Manager Reports Dashboard"""
    if request.user.role.lower() != 'manager':
        messages.error(request, 'Access denied. Manager role required.')
        return redirect('dashboard_redirect')
    
    # Get reports generated by this user
    user_reports = Report.objects.filter(generated_by=request.user).order_by('-created_at')
    
    # Quick portfolio statistics for dashboard
    total_startups = Startup.objects.count()
    active_projects = Project.objects.filter(status='in_progress').count()
    pending_funding = FundingApplication.objects.filter(status='submitted').count()
    overdue_tasks = Task.objects.filter(due_date__lt=timezone.now()).exclude(status='completed').count()
    
    # Report statistics
    total_reports = user_reports.count()
    recent_reports = user_reports[:5]
    
    context = {
        'reports': user_reports,
        'total_reports': total_reports,
        'recent_reports': recent_reports,
        'total_startups': total_startups,
        'active_projects': active_projects,
        'pending_funding': pending_funding,
        'overdue_tasks': overdue_tasks,
    }
    
    return render(request, 'manager/reports.html', context)

@login_required
def generate_manager_report(request):
    """Generate reports for Venture Manager"""
    if request.user.role.lower() != 'manager':
        messages.error(request, 'Access denied.')
        return redirect('dashboard_redirect')
    
    if request.method == 'POST':
        report_type = request.POST.get('report_type')
        date_range = request.POST.get('date_range', 'all_time')
        format_type = request.POST.get('format', 'web')
        
        # Generate report data based on type
        report_data = generate_report_data(report_type, date_range, request.user)
        
        # Create report record
        report_name = f"{report_type.replace('_', ' ').title()} Report - {timezone.now().strftime('%Y-%m-%d')}"
        
        report = Report.objects.create(
            name=report_name,
            report_type=report_type,
            generated_by=request.user,
            content=report_data
        )
        
        if format_type == 'pdf':
            # Generate PDF (you'd implement this with reportlab or similar)
            # pdf_file = generate_pdf_report(report_data)
            # report.file.save(f'{report_name}.pdf', ContentFile(pdf_file))
            messages.success(request, f'{report_name} generated and ready for download!')
            return redirect('reports:download_report', pk=report.pk)
        else:
            messages.success(request, f'{report_name} generated successfully!')
            return redirect('reports:manager_report_detail', pk=report.pk)
    
    # GET request - show report generation form
    return render(request, 'manager/generate_report.html')

@login_required
def manager_report_detail(request, pk):
    """Manager-specific report detail view"""
    report = get_object_or_404(Report, pk=pk)
    
    # Check permissions
    if report.generated_by != request.user:
        messages.error(request, 'You do not have permission to view this report.')
        return redirect('reports:manager_reports')
    
    # Parse report content for display
    try:
        report_data = json.loads(report.content)
    except:
        report_data = {'error': 'Could not parse report data'}
    
    return render(request, 'manager/report_detail.html', {
        'report': report,
        'report_data': report_data,
    })

@login_required
def quick_portfolio_report(request):
    """Generate quick portfolio overview report"""
    if request.user.role.lower() != 'manager':
        messages.error(request, 'Access denied.')
        return redirect('dashboard_redirect')
    
    # Generate real-time portfolio data
    startups = Startup.objects.all()
    projects = Project.objects.all()
    funding_applications = FundingApplication.objects.all()
    
    portfolio_data = {
        'total_startups': startups.count(),
        'startups_by_stage': list(startups.values('stage').annotate(count=Count('id'))),
        'startups_by_industry': list(startups.values('industry').annotate(count=Count('id'))),
        'active_projects': projects.filter(status='in_progress').count(),
        'completed_projects': projects.filter(status='completed').count(),
        'pending_funding': funding_applications.filter(status='submitted').count(),
        'approved_funding': funding_applications.filter(status='approved').count(),
        'total_funding_requested': funding_applications.aggregate(total=Sum('amount_requested'))['total'] or 0,
        'total_funding_approved': funding_applications.filter(status='approved').aggregate(total=Sum('amount_approved'))['total'] or 0,
        'generated_at': timezone.now().isoformat(),
    }
    
    return render(request, 'manager/quick_portfolio_report.html', {
        'portfolio_data': portfolio_data,
        'startups': startups,
        'projects': projects,
    })

@login_required
def project_performance_report(request):
    """Generate project performance report"""
    if request.user.role.lower() != 'manager':
        messages.error(request, 'Access denied.')
        return redirect('dashboard_redirect')
    
    projects = Project.objects.select_related('startup').annotate(
        total_tasks=Count('tasks'),
        completed_tasks=Count('tasks', filter=Q(tasks__status='completed')),
        overdue_tasks=Count('tasks', filter=Q(tasks__due_date__lt=timezone.now()) & ~Q(tasks__status='completed'))
    )
    
    performance_data = {
        'total_projects': projects.count(),
        'projects_by_status': list(projects.values('status').annotate(count=Count('id'))),
        'average_completion_rate': projects.aggregate(
            avg=Avg(Count('tasks', filter=Q(tasks__status='completed')) * 100.0 / Count('tasks'))
        )['avg'] or 0,
        'delayed_projects': projects.filter(status='delayed').count(),
        'high_priority_projects': projects.filter(priority='high').count(),
        'generated_at': timezone.now().isoformat(),
    }
    
    return render(request, 'manager/project_performance_report.html', {
        'performance_data': performance_data,
        'projects': projects,
    })



# Report Generation Helper Functions
def generate_report_data(report_type, date_range, user):
    """Generate report data for manager reports"""
    
    # Calculate date range
    end_date = timezone.now()
    if date_range == 'this_quarter':
        start_date = end_date - timedelta(days=90)
    elif date_range == 'this_year':
        start_date = end_date - timedelta(days=365)
    elif date_range == 'last_30_days':
        start_date = end_date - timedelta(days=30)
    else:
        start_date = None
    
    report_data = {
        'generated_at': timezone.now().isoformat(),
        'date_range': date_range,
        'report_type': report_type,
    }
    
    if report_type == 'portfolio':
        # Portfolio overview report
        startups = Startup.objects.all()
        if start_date:
            startups = startups.filter(created_at__gte=start_date)
        
        report_data.update({
            'total_startups': startups.count(),
            'startups_by_industry': list(startups.values('industry').annotate(count=Count('id'))),
            'startups_by_stage': list(startups.values('stage').annotate(count=Count('id'))),
            'average_team_size': startups.aggregate(avg=Avg('team_size'))['avg'] or 0,
            'total_valuation': startups.aggregate(total=Sum('valuation'))['total'] or 0,
        })
        
    elif report_type == 'performance':
        # Performance metrics report
        projects = Project.objects.all()
        tasks = Task.objects.all()
        
        if start_date:
            projects = projects.filter(created_at__gte=start_date)
            tasks = tasks.filter(created_at__gte=start_date)
        
        report_data.update({
            'total_projects': projects.count(),
            'projects_by_status': list(projects.values('status').annotate(count=Count('id'))),
            'completion_rate': projects.filter(status='completed').count() / max(projects.count(), 1) * 100,
            'total_tasks': tasks.count(),
            'tasks_by_status': list(tasks.values('status').annotate(count=Count('id'))),
            'overdue_tasks': tasks.filter(due_date__lt=timezone.now()).exclude(status='completed').count(),
        })
        
    elif report_type == 'sector':
        # Sector analysis report
        startups = Startup.objects.all()
        if start_date:
            startups = startups.filter(created_at__gte=start_date)
        
        sector_data = []
        for industry in Startup.INDUSTRY_CHOICES:
            industry_startups = startups.filter(industry=industry[0])
            sector_data.append({
                'industry': industry[1],
                'count': industry_startups.count(),
                'avg_valuation': industry_startups.aggregate(avg=Avg('valuation'))['avg'] or 0,
                'avg_revenue': industry_startups.aggregate(avg=Avg('monthly_revenue'))['avg'] or 0,
            })
        
        report_data['sector_analysis'] = sector_data
        
    elif report_type == 'quarterly':
        # Quarterly review report
        quarter_start = end_date - timedelta(days=90)
        
        report_data.update({
            'new_startups': Startup.objects.filter(created_at__gte=quarter_start).count(),
            'new_projects': Project.objects.filter(created_at__gte=quarter_start).count(),
            'completed_projects': Project.objects.filter(
                status='completed', 
                updated_at__gte=quarter_start
            ).count(),
            'funding_applications': FundingApplication.objects.filter(
                created_at__gte=quarter_start
            ).count(),
            'successful_funding': FundingApplication.objects.filter(
                status='approved',
                updated_at__gte=quarter_start
            ).count(),
        })
    
    return report_data

def generate_investor_report_data(report_type, date_range, user):
    """Generate report data for investor reports"""
    
    investments = user.investments.select_related('startup').all()
    
    # Calculate date range
    end_date = timezone.now()
    if date_range == 'this_quarter':
        start_date = end_date - timedelta(days=90)
        investments = investments.filter(investment_date__gte=start_date)
    elif date_range == 'this_year':
        start_date = end_date - timedelta(days=365)
        investments = investments.filter(investment_date__gte=start_date)
    elif date_range == 'last_30_days':
        start_date = end_date - timedelta(days=30)
        investments = investments.filter(investment_date__gte=start_date)
    
    report_data = {
        'generated_at': timezone.now().isoformat(),
        'date_range': date_range,
        'report_type': report_type,
    }
    
    if report_type == 'portfolio':
        # Investor portfolio report
        total_invested = investments.aggregate(Sum('amount'))['amount__sum'] or 0
        portfolio_value = sum(inv.current_value for inv in investments)
        
        report_data.update({
            'total_investments': investments.count(),
            'total_invested': total_invested,
            'current_portfolio_value': portfolio_value,
            'total_return': portfolio_value - total_invested,
            'overall_roi': ((portfolio_value - total_invested) / total_invested * 100) if total_invested > 0 else 0,
            'active_investments': investments.filter(status='active').count(),
            'investments_by_round': list(investments.values('round').annotate(
                count=Count('id'),
                total_amount=Sum('amount')
            )),
        })
        
    elif report_type == 'performance':
        # Investment performance report
        performance_data = []
        for investment in investments:
            performance_data.append({
                'startup_name': investment.startup.name,
                'industry': investment.startup.industry,
                'investment_amount': float(investment.amount),
                'current_value': float(investment.current_value),
                'roi': investment.roi,
                'status': investment.status,
            })
        
        report_data['investments'] = performance_data
        report_data['average_roi'] = sum(inv.roi for inv in investments) / len(investments) if investments else 0
        
    elif report_type == 'sector':
        # Sector analysis for investor
        sector_analysis = []
        for industry in Startup.INDUSTRY_CHOICES:
            industry_investments = investments.filter(startup__industry=industry[0])
            if industry_investments:
                total_invested = industry_investments.aggregate(Sum('amount'))['amount__sum'] or 0
                current_value = sum(inv.current_value for inv in industry_investments)
                sector_analysis.append({
                    'industry': industry[1],
                    'investment_count': industry_investments.count(),
                    'total_invested': total_invested,
                    'current_value': current_value,
                    'average_roi': ((current_value - total_invested) / total_invested * 100) if total_invested > 0 else 0,
                })
        
        report_data['sector_analysis'] = sector_analysis
        
    elif report_type == 'quarterly':
        # Quarterly investment review
        quarter_start = end_date - timedelta(days=90)
        recent_investments = investments.filter(investment_date__gte=quarter_start)
        
        report_data.update({
            'new_investments': recent_investments.count(),
            'total_invested_quarter': recent_investments.aggregate(Sum('amount'))['amount__sum'] or 0,
            'portfolio_growth': calculate_portfolio_growth(investments, quarter_start),
        })
    
    return report_data

def calculate_portfolio_growth(investments, since_date):
    """Calculate portfolio growth since a specific date"""
    # This is a simplified calculation
    # In a real application, you'd track historical valuation data
    recent_investments = investments.filter(investment_date__gte=since_date)
    if recent_investments:
        total_invested = recent_investments.aggregate(Sum('amount'))['amount__sum'] or 0
        current_value = sum(inv.current_value for inv in recent_investments)
        return ((current_value - total_invested) / total_invested * 100) if total_invested > 0 else 0
    return 0